<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>촘촘한 평면 파동 + 강한 이중나선 믹스 (Oculus OK)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block}
  #controls{
    position:fixed;left:10px;top:10px;z-index:10;min-width:300px;
    background:rgba(0,0,0,.6);color:#fff;border-radius:12px;padding:12px;
    font:14px/1.45 system-ui,Segoe UI,Arial
  }
  #controls h3{margin:.2rem 0 .4rem;font-size:15px}
  #controls label{display:flex;justify-content:space-between;align-items:center;margin:.35rem 0;gap:.6rem}
  #controls input[type="number"],#controls input[type="range"]{width:160px}
  #hint{font-size:12px;opacity:.85;margin-top:.5rem}
  button{width:100%;margin-top:.35rem;border-radius:8px;border:0;padding:.45rem .6rem;background:#1f6cff;color:#fff;cursor:pointer}
  button:active{transform:translateY(1px)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:.35rem}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div id="controls">
  <h3>배경 원형 파동(더 촘촘)</h3>
  <label>링 개수 <input id="rings" type="number" min="200" max="2000" step="10" value="900"></label>
  <label>링 간격(px) <input id="gap" type="range" min="1.5" max="10" step="0.1" value="3.2"></label>
  <label>왜곡 진폭(px) <input id="warp" type="range" min="0" max="60" step="1" value="24"></label>
  <label>왜곡 로브 <input id="lobes" type="range" min="1" max="12" step="1" value="4"></label>
  <label>확산 속도 <input id="speed" type="range" min="0" max="8" step="0.1" value="2.0"></label>
  <label>회전 속도(링) <input id="rot" type="range" min="-2" max="2" step="0.05" value="0.20"></label>
  <label>선 두께(px) <input id="lw" type="range" min="0.2" max="1.6" step="0.05" value="0.7"></label>

  <h3 style="margin-top:.7rem">이중 나선(더 강한 믹스)</h3>
  <label>가닥 두께(px) <input id="tw" type="range" min="0.6" max="3.5" step="0.1" value="1.6"></label>
  <label>감김 밀도(턴/화면) <input id="turns" type="range" min="0.5" max="10" step="0.1" value="4.0"></label>
  <label>분리 폭(px) <input id="sep" type="range" min="0" max="120" step="1" value="40"></label>
  <label>상승 속도 <input id="rise" type="range" min="0" max="8" step="0.1" value="2.6"></label>
  <label>Strand↔Waves Mix <input id="mix" type="range" min="0" max="2.0" step="0.05" value="1.0"></label>
  <label>가닥 복제 수 <input id="copies" type="range" min="1" max="6" step="1" value="3"></label>
  <label>복제 오프셋(위상) <input id="copyPhase" type="range" min="0" max="1" step="0.01" value="0.18"></label>
  <label>스트랜드 디테일 <input id="detail" type="range" min="800" max="3600" step="100" value="2400"></label>
  <div class="row">
    <label>시계색 <input id="c1" type="color" value="#00d1ff"></label>
    <label>반시계색 <input id="c2" type="color" value="#ff4dd2"></label>
  </div>

  <h3 style="margin-top:.7rem">성능</h3>
  <label>퍼포먼스 모드 <input id="perf" type="checkbox"></label>

  <button id="apply">적용</button>
  <div id="hint">
    7개의 점을 찍고 <b>Enter</b> → 시작 · <b>Space</b> 일시정지 · <b>F1</b> 패널 토글<br>
    * Oculus Browser에서도 그대로 실행됩니다.
  </div>
</div>

<script>
/* ========== 기본 셋업 ========== */
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d', { alpha:false });
let W = innerWidth, H = innerHeight; canvas.width=W; canvas.height=H;
addEventListener('resize', ()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H});

let mode='points', paused=false, showPanel=true;
const panel=document.getElementById('controls');

const CUSTOM_COLORS = [
  "#32cd32","#00ff7f","#9acd32",
  "#ffff00","#ffd700","#f0e68c",
  "#9370db","#8a2be2","#ba55d3",
  "#1e90ff","#87cefa",
  "#ff6347","#ff4500"
];

/* 유틸 */
const points=[], seeds32=[];
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;}}
async function sha32(str){const buf=new TextEncoder().encode(str);const h=await crypto.subtle.digest('SHA-256',buf);const u=new Uint8Array(h);return ((u[0]<<24)|(u[1]<<16)|(u[2]<<8)|u[3])>>>0;}
function paletteFromSeeds(n){
  const mix = seeds32.reduce((a,b)=>a^b,0)>>>0, r=mulberry32(mix||0x9e3779b9);
  return Array.from({length:n},()=>CUSTOM_COLORS[(r()*CUSTOM_COLORS.length)|0]);
}

/* 파라미터 */
const P = {
  rings:+rings.value, gap:+gap.value, warp:+warp.value, lobes:+lobes.value,
  speed:+speed.value, rot:+rot.value, lw:+lw.value,
  tw:+tw.value, turns:+turns.value, sep:+sep.value, rise:+rise.value,
  mix:+mix.value, copies:+copies.value, copyPhase:+copyPhase.value, detail:+detail.value,
  c1:c1.value, c2:c2.value, perf:perf.checked
};
apply.onclick=()=>{
  P.rings=+rings.value; P.gap=+gap.value; P.warp=+warp.value; P.lobes=+lobes.value;
  P.speed=+speed.value; P.rot=+rot.value; P.lw=+lw.value;
  P.tw=+tw.value; P.turns=+turns.value; P.sep=+sep.value; P.rise=+rise.value;
  P.mix=+mix.value; P.copies=+copies.value; P.copyPhase=+copyPhase.value; P.detail=+detail.value;
  P.c1=c1.value; P.c2=c2.value; P.perf=perf.checked;
};

/* 포인트 입력 */
canvas.addEventListener('mousedown', async (e)=>{
  if(mode!=='points')return;
  const r=canvas.getBoundingClientRect();
  const x=e.clientX-r.left, y=e.clientY-r.top;
  if(points.length<7){
    points.push({x,y});
    seeds32.push(await sha32(`${points.length}:${Math.round(x)}:${Math.round(y)}`));
    drawPoints();
  }
});
function drawPoints(){
  ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle="#00ffcc"; ctx.lineWidth=2; ctx.beginPath();
  for(let i=0;i<points.length;i++){
    const p=points[i]; ctx.fillStyle="#ffee66";
    ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
    if(i===0){ctx.beginPath();ctx.moveTo(p.x,p.y);} else ctx.lineTo(p.x,p.y);
  }
  if(points.length>1) ctx.stroke();
}
document.addEventListener('keydown',(e)=>{
  if(e.code==='Enter' && mode==='points' && points.length===7){ mode='plane'; setupScene(); }
  if(e.code==='Space'){ paused=!paused; }
  if(e.code==='F1'){ e.preventDefault(); showPanel=!showPanel; panel.style.display=showPanel?'block':'none'; }
});

/* 장면 준비 */
let center={x:0,y:0}, palette=[], rngOffsets=[];
function setupScene(){
  center.x = points.reduce((s,p)=>s+p.x,0)/7;
  center.y = points.reduce((s,p)=>s+p.y,0)/7;
  palette = paletteFromSeeds(P.rings);
  const base = seeds32.reduce((a,b)=>a*1664525 + b + 1013904223, 0)>>>0;
  const r=mulberry32(base);
  rngOffsets = new Array(P.rings).fill(0).map(()=>r()*Math.PI*2);
}

/* 렌더 */
function render(t){
  ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
  if(mode==='points'){ drawPoints(); return; }

  const time=t*0.001;
  const phase=time*P.speed, rot=time*P.rot;

  // 화면 덮는 최대 반경
  const maxR = Math.hypot(Math.max(center.x,W-center.x), Math.max(center.y,H-center.y))+40;

  // ===== 배경 파동 (촘촘 & 많게) =====
  ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=P.lw;
  const ringStep = P.perf ? 2 : 1; // 성능 절약 시 홀수/짝수 생략
  for(let i=0;i<P.rings;i+=ringStep){
    const baseR = i*P.gap + (phase*P.gap);
    if(baseR>maxR+P.gap) continue;
    ctx.strokeStyle = palette[i%palette.length];
    ctx.beginPath();

    const offset=rngOffsets[i];
    // 더 촘촘한 세그먼트
    const step=2*Math.PI/(P.perf ? (160+Math.min(220,Math.round(baseR))) : (280+Math.min(360,Math.round(baseR))));
    let first=true;
    for(let th=0; th<2*Math.PI+step; th+=step){
      const a=th+rot;
      const war = P.warp*Math.sin(P.lobes*a + a*0.22 + offset + phase*0.9);
      const rr=baseR+war;
      const x=center.x + Math.cos(a)*rr;
      const y=center.y + Math.sin(a)*rr;
      if(first){ctx.moveTo(x,y);first=false;} else ctx.lineTo(x,y);
    }
    ctx.closePath(); ctx.stroke();
  }

  // ===== 이중 나선 (강한 믹스 + 복제) =====
  const omega = P.rise, turns = P.turns, sep = P.sep;
  const steps = Math.round(P.detail);
  // 투명도를 약간 낮춰 복제겹침이 부드럽게
  const baseAlpha = 0.85 / P.copies;

  function drawStrand(clockwise=true, color="#fff", phaseOffset=0, alphaScale=1){
    ctx.strokeStyle=color;
    ctx.lineWidth=P.tw;
    ctx.globalAlpha = Math.max(0.2, baseAlpha*alphaScale);
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const s=i/steps;
      const r = s*maxR;
      const thetaBase = (clockwise? +1 : -1)*2*Math.PI*turns*s + (clockwise? +1 : -1)*omega*time + phaseOffset;
      const theta = thetaBase + (clockwise? 0 : Math.PI);
      // 배경파동과 강하게 섞기: mix 계수를 크게
      const war = P.mix * P.warp * Math.sin(P.lobes*theta + theta*0.22);
      const rr = r + war;

      // 접선 방향 분리
      const nx = -Math.sin(theta), ny = Math.cos(theta);
      const dx = nx*(clockwise? +sep/2 : -sep/2);
      const dy = ny*(clockwise? +sep/2 : -sep/2);

      const x = center.x + Math.cos(theta)*rr + dx;
      const y = center.y + Math.sin(theta)*rr + dy;

      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1.0;
  }

  // 복제 그리기(시계/반시계 각각 copies개)
  for(let k=0;k<P.copies;k++){
    const po = k * P.copyPhase * 2*Math.PI;   // 위상 오프셋
    const scale = 1 - k*(0.12);               // 바깥 복제는 약간 더 투명
    drawStrand(true,  P.c1, +po, scale);
    drawStrand(false, P.c2, -po, scale);
  }
}

(function loop(t){ if(!paused) render(t); requestAnimationFrame(loop); })();
</script>
</body>
</html>
